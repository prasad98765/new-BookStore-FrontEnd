'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = callbackRegister;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var callbackArray = Symbol();
var eventMap = Symbol();

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function propFnFactory(name) {
  var fn = function fn(e) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (this.props[name]) {
      var _props;

      (_props = this.props)[name].apply(_props, [e].concat(args));
    }

    if (!e.defaultPrevented) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = fn[callbackArray][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _fn = _step.value;

          _fn.call.apply(_fn, [this, e].concat(args));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  fn[callbackArray] = [];

  return fn;
}

function addToEventMap(prototype, events, fn) {
  if (!prototype[eventMap]) {
    prototype[eventMap] = new Map();
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = events[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _event = _step2.value;

      var _name = 'on' + capitalize(_event);

      if (!prototype[eventMap].has(_name)) {
        prototype[eventMap].set(_name, propFnFactory(_name));
      }

      prototype[eventMap].get(_name)[callbackArray].push(fn);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function callbackRegister(component) {
  (0, _invariant2['default'])(!component.prototype.callbacks, '@callbackRegister must be applied to a class with no `callbacks` property');
  (0, _invariant2['default'])(!component.on, '@callbackRegister must be applied to a class with no static `on` property');

  component.on = function (events, fn) {
    if (!Array.isArray(events)) events = [events];

    addToEventMap(component.prototype, events, fn);
  };

  Object.defineProperty(component.prototype, 'callbacks', {
    configurable: true,
    enumerable: true,
    get: function get() {
      var bound = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (this[eventMap] || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2);

          var _name2 = _step3$value[0];
          var unbound = _step3$value[1];

          bound[_name2] = unbound.bind(this);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3['return']) {
            _iterator3['return']();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      // Redefine 'callbacks' with the bound version of our map so we don't
      // need to do it on the next render
      Object.defineProperty(this, 'callbacks', {
        value: bound,
        enumerable: true
      });

      return bound;
    }
  });
}

callbackRegister.on = function () {
  for (var _len2 = arguments.length, events = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    events[_key2] = arguments[_key2];
  }

  return function (prototype, _, descriptor) {
    addToEventMap(prototype, events, descriptor.value);
  };
};
module.exports = exports['default'];