import {createElement, Component} from 'react'
import ReactDOM from 'react-dom'
import TestUtils from 'react-addons-test-utils'
import simulate from 'simulate'
import * as Components from './components'
import controllable from '../src/controllable'


export function renderToContext(context, {componentClass = 'WithPrimaryAction', options = {}, props = {}, form} = {}) {
  context.node = context.node || document.createElement('div')
  context.decorated = context.decorated || controllable(options)(Components[componentClass])

  let rendered
  if (form) {
    context.onSubmit = sinon.spy()
    class FormWrapper extends Component {
      render() {
        return createElement('form', {onSubmit: context.onSubmit}, createElement(context.decorated, props))
      }
    }
    rendered = ReactDOM.render(createElement(FormWrapper), context.node)
  }
  else {
    rendered = ReactDOM.render(createElement(context.decorated, props), context.node)
  }

  context.component = TestUtils.findAllInRenderedTree(rendered, c => !!c.controlState)[0]
  context.focusable = ReactDOM.findDOMNode(context.component.refs.focusable)
  context.target = ReactDOM.findDOMNode(context.component.refs.target)
}


export function pressWindowKey(keyCode) {
  simulate.keyEvent(window, 'keydown', {keyCode})
}


export function releaseWindowKey(keyCode) {
  simulate.keyEvent(window, 'keyup', {keyCode}) 
}


export function itChangesState(state) {
  for (let name in state) {
    if (state.hasOwnProperty(name)) {
      const value = state[name]
      it(`${value ? 'enables' : 'disables'} ${name}`, function() {
        expect(this.component.controlState[name]).to.equal(value)
      })
    }
  }
}


export function itTransitionsOn(description, fn, {from: initial = {}, to: check}) {
  describe(description, function() {
    beforeEach(function() {
      this.component.__setControl(initial)
      fn.call(this)
    })

    for (let name in check) {
      if (check.hasOwnProperty(name)) {
        const value = check[name]
        const initialValue = initial[name]
        const description =
          initialValue === value ? "doesn't change" :
            (value ? "enables" : "disables")

        it(`${description} ${name}`, function() {
          expect(this.component.controlState[name]).to.deep.equal(value)
        })
      }
    }
  })
}


export function itDoesNotTransitionOn(description, fn) {
  const TestState = {
    active: true,
    beacon: null,
    hover: true,
    acting: true,
    selecting: true,
    disabled: false,
  }

  it(`does not transition on ${description}`, function() {
    this.component.__setControl(Object.assign({}, TestState))
    fn.call(this)
    expect(this.component.controlState).to.deep.equal(TestState)
  })

  it(`does not run control primary action on ${description}`, function() {
    this.component.controlPrimaryAction = sinon.spy()
    fn.call(this)
    assert(!this.component.controlPrimaryAction.called)
  })
}


export function fakeEvent() {
  return {preventDefault: function() {}, stopPropagation: function() {}}
}
