require("babel/polyfill")

import {Component, PropTypes, createElement} from 'react'
import TestUtils from 'react-addons-test-utils'
import {KeyCodes, FocusableCallbacks, StyleProps, FormProps} from '../src/constants'
import controllable from '../src/controllable'
import {renderToContext, itTransitionsOn} from './util'
import * as Components from './components'

import './events'
import './behaviors/act'
import './behaviors/cancel'
import './behaviors/selectAndAct'
import './behaviors/submitOrAct'


/*
 * Tests
 */


describe('decorator', function() {
  it("should pass through propTypes from the original class", function() {
    const extendedClass = controllable()(Components.WithPropTypes)
    expect(extendedClass.propTypes.active).to.equal(PropTypes.bool)
    expect(extendedClass.propTypes.onControl).to.equal(PropTypes.func.isRequired)
  })

  it("should add an onControl propType if one doesn't already exist", function() {
    const extendedClass = controllable()(Components.Bare)
    expect(extendedClass.propTypes.onControl).to.equal(PropTypes.func)
  })

  it("should ensure there are no conflicting properties set", function() {
    expect(() => controllable()(Components.ConflictingProperties)).to.throw(Error)
  })
})


describe('decorated class', function() {
  beforeEach(function() {
    renderToContext(this, {
      componentClass: 'WithFormOptions',
      props: {
        className: 'foo',
        tabIndex: 2,
        futureProp: 'bar',
        disabled: false,
      }
    })
  })

  describe('#target', function() {
    beforeEach(function() {
      this.result = this.component.target()
    })

    it("adds pointer-related callbacks", function() {
      expect(this.result.onMouseDown).to.be.a('function')
    })
  })

  describe('#focusable', function() {
    beforeEach(function() {
      this.result = this.component.focusable()
    })

    it("passes through form-related props even when set on original propTypes", function() {
      expect(this.result.tabIndex).to.equal(2)
      expect(this.result.disabled).to.equal(false)
    })

    it("does not pass through style-related props, even if not set on original propTypes", function() {
      expect(this.result.className).to.equal(undefined)
    })

    it("passes through unknown props", function() {
      expect(this.result.futureProp).to.equal('bar')
    })

    it("adds callbacks which require focus", function() {
      expect(this.result.onKeyDown).to.be.a('function')
    })
  })

  describe('#shell', function() {
    beforeEach(function() {
      this.result = this.component.shell()
    })

    it("passes through style-related props", function() {
      expect(this.result.className).to.equal('foo')
    })
  })

  describe('#controlState', function() {
    it("reflects changes", function() {
      this.component.__setControl({beacon: true})
      expect(this.component.controlState.beacon).to.equal(true)

      this.component.__setControl({beacon: false})
      expect(this.component.controlState.beacon).to.equal(false)
    })

    it("cannot be directly updated", function() {
      expect(function() { this.component.controlState.beacon = 'a' }).to.throw(Error)
    })
  })
})


describe('component lifecycle', function() {
  beforeEach(function() {
    renderToContext(this, {
      componentName: 'WithoutPrimaryAction',
      props: {disabled: false}
    })
  })

  it('defaults disabled to false', function() {
    expect(this.component.controlState.disabled).to.equal(false)
  })

  itTransitionsOn('enabling `props.disabled', function() {
    renderToContext(this, {props: {disabled: true}})
  }, {
    from: {acting: true, hover: true, selecting: true},
    to: {acting: false, hover: false, selecting: false, disabled: true}
  })

  it('disabling `props.disabled` sets disabled to false', function() {
    renderToContext(this, {props: {disabled: true}})
    renderToContext(this, {props: {disabled: false}})
    expect(this.component.controlState.disabled).to.equal(false)
  })
})
